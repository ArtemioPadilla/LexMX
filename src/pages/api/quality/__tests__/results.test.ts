import { describe, it, expect, beforeEach, vi } from 'vitest';
import type { APIContext } from 'astro';

// Mock the QualityTestSuite class
vi.mock('../../../../lib/admin/quality-test-suite', () => {
  const mockStoredResults = [
    {
      suiteName: 'Mexican Legal Quality Suite',
      totalTests: 15,
      passedTests: 12,
      averageScore: 0.82,
      totalDuration: 18000,
      results: [
        {
          testId: 'citation-art-123',
          passed: true,
          score: 0.95,
          duration: 1200,
          details: [
            {
              expectation: { type: 'contains_text', value: 'derecho al trabajo', description: 'Should contain labor rights text' },
              passed: true,
              actualValue: 'Found: derecho al trabajo',
              score: 1.0,
              message: 'Text found successfully'
            }
          ],
          response: {
            answer: 'El artÃ­culo 123 constitucional establece el derecho al trabajo...',
            confidence: 0.95,
            sources: ['constitucion-politica-mexico.json'],
            legalArea: 'labor',
            queryType: 'citation'
          },
          timestamp: Date.now()
        },
        {
          testId: 'semantic-labor',
          passed: true,
          score: 0.88,
          duration: 1500,
          details: [],
          timestamp: Date.now()
        },
        {
          testId: 'citation-failed',
          passed: false,
          score: 0.35,
          duration: 2000,
          details: [],
          error: 'Citation not found',
          timestamp: Date.now()
        }
      ],
      timestamp: Date.now()
    },
    {
      suiteName: 'Mexican Legal Quality Suite',
      totalTests: 15,
      passedTests: 10,
      averageScore: 0.78,
      totalDuration: 19500,
      results: [
        {
          testId: 'citation-art-123',
          passed: true,
          score: 0.90,
          duration: 1300,
          details: [],
          timestamp: Date.now() - 86400000
        }
      ],
      timestamp: Date.now() - 86400000 // 1 day ago
    },
    {
      suiteName: 'Mexican Legal Quality Suite',
      totalTests: 12,
      passedTests: 8,
      averageScore: 0.75,
      totalDuration: 15000,
      results: [],
      timestamp: Date.now() - 172800000 // 2 days ago
    }
  ];

  const mockQualityTestSuite = {
    getStoredResults: vi.fn().mockReturnValue(mockStoredResults),
    generateReport: vi.fn().mockImplementation((result) => {
      return `# Quality Test Report - ${result.suiteName}

## Summary
- **Total Tests**: ${result.totalTests}
- **Passed Tests**: ${result.passedTests}
- **Average Score**: ${(result.averageScore * 100).toFixed(1)}%
- **Total Duration**: ${result.totalDuration}ms
- **Timestamp**: ${new Date(result.timestamp).toISOString()}

## Test Results
${result.results.map(r => `- ${r.testId}: ${r.passed ? 'PASSED' : 'FAILED'} (${(r.score * 100).toFixed(1)}%)`).join('\n')}

## Details
Generated by LexMX Quality Test Suite
`;
    }),
    exportResults: vi.fn().mockImplementation(async (result) => {
      const report = `# Quality Test Report - ${result.suiteName}

## Summary
- **Total Tests**: ${result.totalTests}
- **Passed Tests**: ${result.passedTests}
- **Average Score**: ${(result.averageScore * 100).toFixed(1)}%

Generated on ${new Date().toISOString()}
`;
      return new Blob([report], { type: 'text/markdown' });
    })
  };

  return {
    QualityTestSuite: vi.fn().mockImplementation(() => mockQualityTestSuite),
    qualityTestSuite: mockQualityTestSuite
  };
});

// Mock localStorage for testing
const mockLocalStorage = {
  removeItem: vi.fn(),
  getItem: vi.fn(),
  setItem: vi.fn()
};

Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage
});

// Import after mocking
import { GET, DELETE, POST, OPTIONS } from '../results';

describe('Quality Results API Endpoint', () => {
  let mockContext: APIContext;

  beforeEach(() => {
    vi.clearAllMocks();
    mockLocalStorage.removeItem.mockClear();

    mockContext = {
      request: new Request('http://localhost:3000/api/quality/results', {
        method: 'GET'
      }),
      params: {},
      props: {},
      url: new URL('http://localhost:3000/api/quality/results'),
      cookies: {} as any,
      locals: {},
      redirect: vi.fn() as any,
      site: new URL('http://localhost:3000'),
      generator: 'Astro',
      clientAddress: '127.0.0.1'
    } as APIContext;
  });

  describe('GET /api/quality/results', () => {
    describe('Historical Results', () => {
      it('should return historical results with default limit', async () => {
        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.results).toHaveLength(3);
        expect(data.data.count).toBe(3);
        expect(data.data.totalAvailable).toBe(3);
        expect(data.data.hasMore).toBe(false);
      });

      it('should respect limit parameter', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?limit=2');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.results).toHaveLength(2);
        expect(data.data.count).toBe(2);
        expect(data.data.totalAvailable).toBe(3);
        expect(data.data.hasMore).toBe(true);
      });

      it('should handle limit larger than available results', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?limit=20');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.results).toHaveLength(3);
        expect(data.data.count).toBe(3);
        expect(data.data.hasMore).toBe(false);
      });

      it('should handle zero limit', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?limit=0');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.results).toHaveLength(0);
        expect(data.data.count).toBe(0);
        expect(data.data.hasMore).toBe(true);
      });
    });

    describe('Latest Results', () => {
      it('should return latest test results', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?latest=true');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.suiteName).toBe('Mexican Legal Quality Suite');
        expect(data.data.totalTests).toBe(15);
        expect(data.data.passedTests).toBe(12);
        expect(data.data.averageScore).toBe(0.82);
        expect(data.data.results).toHaveLength(3);
        expect(data.message).toBe('Latest test results retrieved');
      });

      it('should return latest results as markdown report', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?latest=true&format=report');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const text = await response.text();

        expect(response.status).toBe(200);
        expect(response.headers.get('Content-Type')).toBe('text/markdown');
        expect(text).toContain('# Quality Test Report - Mexican Legal Quality Suite');
        expect(text).toContain('**Total Tests**: 15');
        expect(text).toContain('**Passed Tests**: 12');
        expect(text).toContain('**Average Score**: 82.0%');
      });

      it('should handle no results available for latest', async () => {
        const { qualityTestSuite } = await import('../../../../lib/admin/quality-test-suite');
        qualityTestSuite.getStoredResults = vi.fn().mockReturnValue([]);

        mockContext.url = new URL('http://localhost:3000/api/quality/results?latest=true');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.results).toHaveLength(0);
      });
    });

    describe('Format Options', () => {
      it('should return summary format', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?format=summary');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.summary).toBeDefined();
        expect(data.data.summary).toHaveLength(3);
        expect(data.data.summary[0]).toHaveProperty('timestamp');
        expect(data.data.summary[0]).toHaveProperty('suiteName');
        expect(data.data.summary[0]).toHaveProperty('totalTests');
        expect(data.data.summary[0]).toHaveProperty('passedTests');
        expect(data.data.summary[0]).toHaveProperty('averageScore');
        expect(data.data.summary[0]).toHaveProperty('passRate');
        expect(data.data.summary[0].passRate).toBe('80.0');
      });

      it('should handle format=json (default)', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?format=json');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        expect(data.data.results).toBeDefined();
        expect(data.data.summary).toBeUndefined();
      });
    });

    describe('Error Handling', () => {
      it('should handle service errors gracefully', async () => {
        const { qualityTestSuite } = await import('../../../../lib/admin/quality-test-suite');
        qualityTestSuite.getStoredResults = vi.fn().mockImplementation(() => {
          throw new Error('Storage service unavailable');
        });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(500);
        expect(data.success).toBe(false);
        expect(data.error).toContain('Storage service unavailable');
      });

      it('should handle invalid limit parameter', async () => {
        mockContext.url = new URL('http://localhost:3000/api/quality/results?limit=invalid');
        mockContext.request = new Request(mockContext.url.toString(), { method: 'GET' });

        const response = await GET(mockContext);
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.success).toBe(true);
        // Should default to 10 when limit is invalid
        expect(data.data.results).toHaveLength(3);
      });
    });

    describe('CORS Headers', () => {
      it('should include CORS headers in successful response', async () => {
        const response = await GET(mockContext);

        expect(response.headers.get('Access-Control-Allow-Origin')).toBe('*');
        expect(response.headers.get('Access-Control-Allow-Methods')).toBe('GET, POST, DELETE, OPTIONS');
        expect(response.headers.get('Access-Control-Allow-Headers')).toBe('Content-Type, Authorization');
        expect(response.headers.get('Content-Type')).toBe('application/json');
      });

      it('should include CORS headers in error response', async () => {
        const { qualityTestSuite } = await import('../../../../lib/admin/quality-test-suite');
        qualityTestSuite.getStoredResults = vi.fn().mockImplementation(() => {
          throw new Error('Service error');
        });

        const response = await GET(mockContext);

        expect(response.headers.get('Access-Control-Allow-Origin')).toBe('*');
        expect(response.headers.get('Content-Type')).toBe('application/json');
      });
    });
  });

  describe('DELETE /api/quality/results', () => {
    beforeEach(() => {
      mockContext.request = new Request('http://localhost:3000/api/quality/results', {
        method: 'DELETE'
      });
    });

    it('should clear stored test results', async () => {
      const response = await DELETE(mockContext);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.message).toBe('Quality test results cleared successfully');
      expect(mockLocalStorage.removeItem).toHaveBeenCalledWith('lexmx_quality_test_results');
    });

    it('should handle localStorage error gracefully', async () => {
      mockLocalStorage.removeItem.mockImplementation(() => {
        throw new Error('Storage error');
      });

      const response = await DELETE(mockContext);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.success).toBe(true);
      expect(data.message).toBe('Quality test results cleared successfully');
    });

    it('should include CORS headers in DELETE response', async () => {
      const response = await DELETE(mockContext);

      expect(response.headers.get('Access-Control-Allow-Origin')).toBe('*');
      expect(response.headers.get('Access-Control-Allow-Methods')).toBe('GET, POST, DELETE, OPTIONS');
      expect(response.headers.get('Access-Control-Allow-Headers')).toBe('Content-Type, Authorization');
      expect(response.headers.get('Content-Type')).toBe('application/json');
    });
  });

  describe('POST /api/quality/results', () => {
    describe('Export Latest Operation', () => {
      beforeEach(() => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'export_latest' })
        });
      });

      it('should export latest test results', async () => {
        const response = await POST(mockContext);
        const text = await response.text();

        expect(response.status).toBe(200);
        expect(response.headers.get('Content-Type')).toBe('text/markdown');
        expect(response.headers.get('Content-Disposition')).toContain('attachment; filename="quality-report-');
        expect(text).toContain('# Quality Test Report - Mexican Legal Quality Suite');
        expect(text).toContain('**Total Tests**: 15');
        expect(text).toContain('**Passed Tests**: 12');
      });

      it('should handle no results available for export', async () => {
        const { qualityTestSuite } = await import('../../../../lib/admin/quality-test-suite');
        qualityTestSuite.getStoredResults = vi.fn().mockReturnValue([]);

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(404);
        expect(data.success).toBe(false);
        expect(data.error).toBe('No test results available for export');
      });
    });

    describe('Export by Timestamp Operation', () => {
      it('should export test results by timestamp', async () => {
        const timestamp = Date.now();
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            operation: 'export_by_timestamp',
            timestamp: timestamp.toString()
          })
        });

        // Mock to return a result with the specific timestamp
        const { qualityTestSuite } = await import('../../../../lib/admin/quality-test-suite');
        qualityTestSuite.getStoredResults = vi.fn().mockReturnValue([
          {
            suiteName: 'Mexican Legal Quality Suite',
            totalTests: 10,
            passedTests: 8,
            averageScore: 0.8,
            totalDuration: 12000,
            results: [],
            timestamp: timestamp
          }
        ]);

        const response = await POST(mockContext);
        const text = await response.text();

        expect(response.status).toBe(200);
        expect(response.headers.get('Content-Type')).toBe('text/markdown');
        expect(response.headers.get('Content-Disposition')).toContain(`attachment; filename="quality-report-${timestamp}.md"`);
        expect(text).toContain('# Quality Test Report - Mexican Legal Quality Suite');
      });

      it('should handle missing timestamp parameter', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'export_by_timestamp' })
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(400);
        expect(data.success).toBe(false);
        expect(data.error).toBe('Timestamp is required for export_by_timestamp operation');
      });

      it('should handle timestamp not found', async () => {
        const nonExistentTimestamp = Date.now() + 100000;
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            operation: 'export_by_timestamp',
            timestamp: nonExistentTimestamp.toString()
          })
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(404);
        expect(data.success).toBe(false);
        expect(data.error).toBe(`No test results found for timestamp ${nonExistentTimestamp}`);
      });
    });

    describe('Invalid Operations', () => {
      it('should handle invalid operation', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'invalid_operation' })
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(400);
        expect(data.success).toBe(false);
        expect(data.error).toBe('Invalid operation. Valid operations: export_latest, export_by_timestamp');
      });

      it('should handle missing operation', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(400);
        expect(data.success).toBe(false);
        expect(data.error).toBe('Invalid operation. Valid operations: export_latest, export_by_timestamp');
      });
    });

    describe('Request Validation', () => {
      it('should handle malformed JSON', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: 'invalid json'
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(500);
        expect(data.success).toBe(false);
        expect(data.error).toBeTruthy();
      });

      it('should handle empty request body', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(500);
        expect(data.success).toBe(false);
        expect(data.error).toBeTruthy();
      });
    });

    describe('Export Error Handling', () => {
      it('should handle export service errors', async () => {
        const { qualityTestSuite } = await import('../../../../lib/admin/quality-test-suite');
        qualityTestSuite.exportResults = vi.fn().mockRejectedValue(new Error('Export failed'));

        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'export_latest' })
        });

        const response = await POST(mockContext);
        const data = await response.json();

        expect(response.status).toBe(500);
        expect(data.success).toBe(false);
        expect(data.error).toContain('Export failed');
      });
    });

    describe('CORS Headers', () => {
      it('should include CORS headers in successful POST response', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ operation: 'export_latest' })
        });

        const response = await POST(mockContext);

        expect(response.headers.get('Access-Control-Allow-Origin')).toBe('*');
      });

      it('should include CORS headers in POST error response', async () => {
        mockContext.request = new Request('http://localhost:3000/api/quality/results', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: 'invalid json'
        });

        const response = await POST(mockContext);

        expect(response.headers.get('Access-Control-Allow-Origin')).toBe('*');
        expect(response.headers.get('Content-Type')).toBe('application/json');
      });
    });
  });

  describe('OPTIONS /api/quality/results', () => {
    beforeEach(() => {
      mockContext.request = new Request('http://localhost:3000/api/quality/results', {
        method: 'OPTIONS'
      });
    });

    it('should handle OPTIONS request for CORS preflight', async () => {
      const response = await OPTIONS(mockContext);

      expect(response.status).toBe(200);
      expect(response.headers.get('Access-Control-Allow-Origin')).toBe('*');
      expect(response.headers.get('Access-Control-Allow-Methods')).toBe('GET, POST, DELETE, OPTIONS');
      expect(response.headers.get('Access-Control-Allow-Headers')).toBe('Content-Type, Authorization');
    });

    it('should return no content for OPTIONS', async () => {
      const response = await OPTIONS(mockContext);
      const text = await response.text();

      expect(text).toBe('');
    });
  });
});